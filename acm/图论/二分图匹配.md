# 前置

## 定义

图 $G=(V,E)$，其中$V$是点集，$E$是边集

一组两两没有公共点的边集 $(M(M\in E))$称为这张图的 **匹配**。

定义匹配的大小为其中边的数量 $|M|$，其中边数最大的大的 $M$ 为 **最大匹配**。

当图中的边带权的时候，边权和最大的为 **最大权匹配**。

匹配中的边称为 **匹配边**，反之称为 **未匹配边**。

一个点如果属于 $M$且为至多一条边的端点，称为 **匹配点**，反之称为 **未匹配点**。

完美匹配：所有点都属于匹配点，同时也符合最大匹配

增广路：也称**交错路**，是一条连接两个非匹配点，且匹配边与非匹配边交错出现的路径

增广路显然具有以下性质：

1.长度$len$是奇数

2.路径上第$1,3,5,\cdot\cdot\cdot,len$是非匹配边，第$2,4,5,\cdot\cdot\cdot,len-1$是匹配边

推论

**二分图的一组匹配$M$是最大匹配，当且仅当图中不存在$S$的增广路**

# 二分图最大匹配

## code

因为增广路长度为奇数，路径起始点非左即右，所以我们先考虑从左边的未匹配点找增广路。 注意到因为交错路的关系，增广路上的第奇数条边都是非匹配边，第偶数条边都是匹配边，于是左到右都是非匹配边，右到左都是匹配边。 于是我们给二分图 **定向**，问题转换成，有向图中从给定起点找一条简单路径走到某个未匹配点，此问题等价给定起始点 $s$(/yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 能否走到终点 ![t](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)。 那么只要从起始点开始 DFS 遍历直到找到某个未匹配点，![O(m)](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)。 未找到增广路时，我们拓展的路也称为 **交错树**。

$O(NM)$

```c++
//点0~n-1 , 
namespace augment_path {
	vector<vector<int> > g;
	vector<int> pa;  	// 左部点匹配
	vector<int> pb;	// 右部点匹配
	vector<int> vis;  // 访问
	vector<int> ext;
	int n, m;         // 两个点集中的顶点数量 左部点,右部点
	int dfn;          // 时间戳记，代替memset加快效率 
	int res;          // 匹配数

	void init(int _n,int _m){
		n = _n, m = _m;
		assert(0 <= n && 0 <= m);
	    pa = vector<int>(n, -1);
	    pb = vector<int>(m, -1);
	    vis = vector<int>(n);
	    g.resize(n);
	    res = 0;
	    dfn = 0;
	} 
	void add(int from, int to) { //注意减一 
    	assert(0 <= from && from < n && 0 <= to && to < m);
    	g[from].push_back(to);
	}

	bool bfs(int v) {
		vis[v] = dfn; //标记访问
		for (int u : g[v]) {
			if (pb[u] == -1) { //如果右部点u没有匹配，我们就直接连接u,v 
				pb[u] = v;
				pa[v] = u;
				return true;
			}
		}
		for (int u : g[v]) {  //否则尝试找一条增广路 
		  if (vis[pb[u]] != dfn && bfs(pb[u])) { //没有访问过就尝试找增广路 
			    pa[v] = u;
			    pb[u] = v;
			    return true;
		  	}
		}
		return false;
	}

	int solve() {
		while (true) {
		  dfn++;
		  int cnt = 0;
		  for (int i = 0; i < n; i++) {
		    if (pa[i] == -1 && bfs(i)) { //如果左部点i没有匹配，我们就dfs尝试匹配 
		      cnt++;
		    }
		  }
		  if (cnt == 0) {
		    break;
		  }
		  res += cnt;
		}
		return res;
	}
	
	//用于字典序最小 ,左部点每个点度数不超过2 
	bool dfs(int v) {
		for (int u : g[v]) {
			if(vis[u] != dfn){
				vis[u] = dfn; //标记访问
				if(pb[u] == -1 || dfs(pb[u])){//如果右部点u没有匹配或者能找到增广路，我们就直接连接u,v 
					pb[u] = v;
					pa[v] = u;
					return true;
				}
			}
		}
		return false;
	}
	
	int ssolve() { //作用和上面那个solve一样，效率低但是便于修改 
		int cnt = 0;

		for (int i = n - 1; i >= 0; i--) {
			dfn++;
			if (pa[i] == -1 && dfs(i)) { //如果左部点i没有匹配，我们就dfs尝试匹配 
			  		cnt++;
			}

		}
		res += cnt;
		return res;
	}
	
	//用于求字典序最小的完美匹配 
	bool dfs_min(int v) {
		if(vis[v] == dfn || ext[v])return 0;
		vis[v] = dfn;
		for (int u : g[v]) {
			if(ext[n + u])continue;
			if(pb[u] == -1 || dfs_min(pb[u]))
			{
				pb[u] = v;
				pa[v] = u;
				return true;
			}
		}
		return false;
	}
	
	bool solve_min() { 
		solve();
		if(res != n)return false;
		
		//先看看可不可以，再考虑最小
		
		ext.resize(2 * n, 0);
		for(int i = 0; i < n; ++i)
		{
			for(int p = 0; p < g[i].size(); ++p)//每一次都强制匹配i和y，然后pa[i]与pb[i]失配重连
			{
				int y = g[i][p];
				bool check = 0;
				if(pa[i] == y)check = 1;
				else
				{
					ext[i] = 1;
					ext[y + n] = 1;
					pb[pa[i]] = -1;
					dfn++;
					if(dfs_min(pb[y]))check = 1;
					else pb[pa[i]] = i;
					ext[i] = 0;
					ext[y + n] = 0;
				}
				if(check)
				{
					pa[i] = y;
					pb[y] = i;
					ext[i] = ext[n + y] = 1;
					break;
				}
			
			}
		}
		
		return 1;
	}
};

```

对于字典序最小的方案,如果左部点最多只有两条边与之相连,那么我们倒着枚举左部点,同时让边的终点从小到大放入图即可

证明

首先，我们不停地选择右边只有一条连边的点。由于要达到完美匹配，与它相连的左边的点必须与它匹配。所以可以把那个点连的两条边删掉。

此时，所有右边度数为 11 的点都被删完了，所以 $min>=2$。而右边总度数开始时为 $2n$，每匹配一个点度数 −2，所以假设剩下 $k$ 个点，总度数一定为 $2n-2(n−k)=2n−2(n−k)=2k$，又因为$min>=2$ ，所以每个右边的点度数都为 2。

然后因为图中每个点度数都为 2，所以被分成了若干个度数为 2 的环。倒着匹配的过程中，确定了一个匹配后，两个端点所连的另两个点的匹配也就确定了，一直循环下去，环中所有剩余的匹配也就确定了（自己模拟一下有助于理解）。所以虽然有后效性，但在后面的过程中只有一种选择，就一定可以保证字典序最小了。



# 二分图带权完备匹配

## 前置

相等子图$(A_i+B_j = w(i,j))$的完备匹配是带权最大匹配。



## code

顶标全称”定点标记值“，满足$A_i+B_j \geq w(i,j) $。





```c++
//0~n-1
template <typename T>
struct hungarian {  	// km
  int n;               	//max(左部点个数，右部点个数)
  vector<int> matchx;  	// 左集合对应的匹配点
  vector<int> matchy;  	// 右集合对应的匹配点
  vector<int> pre;     	// 连接右集合的左点
  vector<bool> visx;   	// 拜访数组 左
  vector<bool> visy;   	// 拜访数组 右
  vector<T> lx;        	//左部顶标
  vector<T> ly;			//右部顶标
  vector<vector<T> > g; //图
  vector<T> slack;
  T inf;
  T res;
  queue<int> q;
  int org_n;
  int org_m;

  hungarian(int _n, int _m) {
    org_n = _n;
    org_m = _m;
    n = max(_n, _m);
    inf = numeric_limits<T>::max();//返回数据类型T的最大值
    res = 0;
    g = vector<vector<T> >(n, vector<T>(n));
    matchx = vector<int>(n, -1);
    matchy = vector<int>(n, -1);
    pre = vector<int>(n);
    visx = vector<bool>(n);
    visy = vector<bool>(n);
    lx = vector<T>(n, -inf);
    ly = vector<T>(n);
    slack = vector<T>(n);
  }

  void addEdge(int u, int v, int w) {
    assert(0 <= u && u < n && 0 <= v && v < m);
    g[u][v] = max(w, 0);  // 负值还不如不匹配 因此设为0不影响
  }

  bool check(int v) {
    visy[v] = true;
    if (matchy[v] != -1) {
      q.push(matchy[v]);
      visx[matchy[v]] = true;  // in S
      return false;
    }
    // 找到新的未匹配点 更新匹配点 pre 数组记录着"非匹配边"上与之相连的点
    while (v != -1) {
      matchy[v] = pre[v];
      swap(v, matchx[pre[v]]);
    }
    return true;
  }

  void bfs(int i) {
    while (!q.empty()) {
      q.pop();
    }
    q.push(i);
    visx[i] = true;
    while (true) {
      while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v = 0; v < n; v++) {
          if (!visy[v]) {
            T delta = lx[u] + ly[v] - g[u][v];
            if (slack[v] >= delta) {
              pre[v] = u;
              if (delta) {
                slack[v] = delta;
              } else if (check(v)) {  // delta=0 代表有机会加入相等子图 找增广路
                                      // 找到就return 重建交错树
                return;
              }
            }
          }
        }
      }
      // 没有增广路 修改顶标
      T a = inf;
      for (int j = 0; j < n; j++) {
        if (!visy[j]) {
          a = min(a, slack[j]);
        }
      }
      for (int j = 0; j < n; j++) {
        if (visx[j]) {  // S
          lx[j] -= a;
        }
        if (visy[j]) {  // T
          ly[j] += a;
        } else {  // T'
          slack[j] -= a;
        }
      }
      for (int j = 0; j < n; j++) {
        if (!visy[j] && slack[j] == 0 && check(j)) {
          return;
        }
      }
    }
  }

  void solve() {
    // 初始顶标
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        lx[i] = max(lx[i], g[i][j]);
      }
    }

    for (int i = 0; i < n; i++) {
      fill(slack.begin(), slack.end(), inf);
      fill(visx.begin(), visx.end(), false);
      fill(visy.begin(), visy.end(), false);
      bfs(i);
    }

    // custom
    for (int i = 0; i < n; i++) {
      if (g[i][matchx[i]] > 0) {
        res += g[i][matchx[i]];
      } else {
        matchx[i] = -1;
      }
    }
    cout << res << "\n";
    for (int i = 0; i < org_n; i++) {
      cout << matchx[i] + 1 << " ";
    }
    cout << "\n";
  }
};
```



# 一般图最大匹配

# 一般图带权匹配