## 网络流的优化

网络流处理的其实是单向边，对于双向边，可以正反连一条容量都为$c$的

## 基础网络流

## code

```c++

const int N=20010,M=1000010;
int head[N],ver[M],nxt[M],d[N];
ll edge[M];
int now[M];//弧优化 
int tot=0,n,m,dx;
const int inf=1<<30;
void add(int x,int y,ll z)
{
	ver[++tot]=y;edge[tot]=z;
	nxt[tot]=head[x];head[x]=tot;
	ver[++tot]=x;edge[tot]=0;
	nxt[tot]=head[y];head[y]=tot;
}

int st,t;//源点，汇点 
bool bfs()
{
	memset(d,0,sizeof(d));
//	while(q.size())q.pop();
	queue<int>q;
	q.push(st);
	d[st]=1;
	now[st]=head[st]; 
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(int i=head[x];i!=-1;i=nxt[i])
		{
			int y=ver[i];
			if(edge[i]&&!d[y])
			{
				q.push(y);
				now[y]=head[y];
				d[y]=d[x]+1;
				if(y==t)return 1;
			}
		}
	}
	return 0;
}
ll dfs(int x,ll flow)
{
	if(x==t)return flow;
	ll rest=flow,k;
	for(int i=now[x];i!=-1&&rest;i=nxt[i])
	{
		now[x]=i;
		int y=ver[i];
		if(edge[i]&&d[y]==d[x]+1)
		{
			k=dfs(y,min(rest,edge[i]));
			if(!k)d[ver[i]]=0;
			edge[i]-=k;
			edge[i^1]+=k;
			rest-=k;
		}
	}
	return flow-rest;
}
ll dinic()
{
	ll flow=0,ans=0;
	while(bfs())
	{
		while(flow=dfs(st,inf))ans+=flow;
	}
	return ans;
}
int dd=0;
struct node
{
	int ver;
	ll v;
	bool operator< (const node &a)const
	{
		return v>a.v;
	}
};
vector<node>a[N];
ll dis[N];
bool v[N];
void dij()
{
	memset(dis,0x3f,sizeof(dis));
	memset(v,0,sizeof(v));
	dis[1]=0;
	priority_queue<node>q;
	node t;
	t.v=dis[1];
	t.ver=1;
	q.push(t);
	while(!q.empty())
	{
		t=q.top();
		q.pop();
		int x=t.ver;
		if(v[x])continue;
		v[x]=1;
		for(int i=0;i<a[x].size();i++)
		{
			int y=a[x][i].ver;
			ll z=a[x][i].v;
			if(!v[y]&&dis[y]>dis[x]+z)
			{
				dis[y]=dis[x]+z; 
				node tt;
				tt.ver=y;
				tt.v=dis[y];
				q.push(a[x][i]);
			}
		}
	}
}
void solve()
{	
	scanf("%d%d",&n,&m);
	int res=0;
	st=1,t=n;
	tot=1;
	memset(head,-1,sizeof(head));
	for(int i=1;i<=n;++i)a[i].clear();
	for(int i=1;i<=m;i++)
	{
		int x;
		node y;
		scanf("%d%d%lld",&x,&y.ver,&y.v);
		a[x].push_back(y);
	}
	dij();
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<a[i].size();j++)
		{
			int y=a[i][j].ver; 
			if(dis[y]==dis[i]+a[i][j].v)
			{
				add(i,y,a[i][j].v);
			}
		}
	}
	ll ans=dinic();
	printf("%lld\n",ans);
}
```

