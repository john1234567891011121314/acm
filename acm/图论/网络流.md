## 基本概念

我们可以将流网络的每一条有向边看成看成一个流通通道，每条边的容量看成流经该通道的最大速率。

我们将$c(u,v)$记作有向边$u-v$的容量，而$f(u,v)$记作这条边的流量。同时具有以下性质：

1. 容量限制。$0 \leq f(u,v) \leq c(u,v)$
2. 流量守恒。$\sum_{v \in V} f(v,u) = \sum_{v \in V} f(u,v)$。即流入等于流出

一个流$f$的值定义如下：
$$
|f| = \sum_{v \in V}f(s,v) - \sum_{v \in V} f(v,s)
$$
即流$f$的值定义为从源节点流出的总流量减去流入源节点的总流量



## 基础网络流

在网络流中有一个比较重要的概念：残存网络。

假如我们已经找到一个流，那么我们可以在整张图里把这个流给去掉，得到了一个残留图，因为我们的目标是想方设法增大容量，那么我们还需要一个反向流量，使其可以减小正向流量然后增大总的流。

形式化的表示为
$$
c_f(u,v)= 
	\begin{cases} 
	c(u,v)-f(u,v) & \mbox{if} (u,v) \in E  \\
	f(v,u) &	\mbox{if} (v,u) \in E \\
	0
	\end{cases}
	
$$
对于抵消操作，可以理解为$u$送给$v$五箱橘子，$v$送给$u$三箱橘子，那么就等价于$u$给$v$两箱橘子。

那么我们就可以在残量图中继续求解最大流

## code

dinic算法复杂度为$O(n^2m)$，通常$1e4 - 1e5$都能处理

求解二分图匹配复杂度为$O(m \sqrt{n})$

```c++
struct MF {
	struct edge {
		int v, nxt;
		ll cap;
	} e[M];

  	int head[N], cnt = 1;
	ll INF = 1e18;
  	int n, S, T;	//点的个数，源点，汇点
  	ll maxflow = 0;
  	int dep[N], cur[N], now[N];
	
    void init(int _n, int s, int t)
    {
        n = _n;
        for(int i = 0; i <= n; ++i) head[i] = 0;
        for(int i = 0; i <= n; ++i) now[i] = 0;
        S = s;
        T = t;
        cnt = 1;
        maxflow = 0;
    }
  	void addedge(int u, int v, ll w, ll f = 0) {
    	e[++cnt] = {v, head[u], w};
    	head[u] = cnt;
    	e[++cnt] = {u, head[v], f};
    	head[v] = cnt;
  	}

  	bool bfs() {
    	queue<int> q;
//    	memset(dep, 0, sizeof(dep));
    	for(int i = 0; i <= n; ++i)dep[i] = 0;

    	dep[S] = 1;
    	q.push(S);
    	now[S] = head[S];
    	while (!q.empty()) {
    		int u = q.front();
    		q.pop();
      		for (int i = head[u]; i; i = e[i].nxt) {
        		int v = e[i].v;
        		if (!dep[v] && e[i].cap) {	
          			dep[v] = dep[u] + 1;
          			q.push(v);
          			now[v] = head[v];
          			if(v == T) return 1;
        		}
      		}
    	}
		return 0;
 	}

  	ll dfs(int u, ll flow) {
    
		if(u == T) return flow;
    	ll ret = flow, k;
    	for (int i = now[u]; i && ret; i = e[i].nxt) {
    		int v = e[i].v;
    		now[u] = i;
    		if(e[i].cap && dep[v] == dep[u] + 1)
       		{
        		k = dfs(v, min(ret, e[i].cap));
        		if(!k) dep[v] = 0;
        		e[i].cap -= k;
        		e[i ^ 1].cap += k;
           		ret -= k;
       		}
    	}
    	return flow - ret;
  	}

  	void dinic() {
    	ll flow = 0;
    	while (bfs()) {
//    		flow = dfs(S, INF);
      		while(flow = dfs(S, INF))  {
      			maxflow += flow;
      	
    		}
    	}
  	}
} mf;
```





## 网络流的优化

网络流处理的其实是单向边，对于双向边，可以正反连一条容量都为$c$的